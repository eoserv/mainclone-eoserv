#ifndef EOSERV_HPP_INCLUDED
#define EOSERV_HPP_INCLUDED

#include <vector>
#include <ctime>
#include <string>

class World;
class Player;
class Character;
class Guild;
class Party;
class NPC;
class Map;

struct Map_Item;
struct Character_Item;
struct Character_Spell;
struct NPC_Opponent;

#include "database.hpp"
#include "util.hpp"
#include "config.hpp"
#include "eoconst.hpp"
#include "timer.hpp"
#include "socket.hpp"
#include "packet.hpp"
#include "eodata.hpp"

extern World *the_world;

/**
 * Serialize a list of items in to a text format that can be restored with ItemUnserialize
 */
std::string ItemSerialize(std::list<Character_Item> list);

/**
 * Convert a string generated by ItemSerialze back to a list of items
 */
std::list<Character_Item> ItemUnserialize(std::string serialized);

/**
 * Serialize a paperdoll of 15 items in to a string that can be restored with DollUnserialize
 */
std::string DollSerialize(util::array<int, 15> list);

/**
 * Convert a string generated by DollSerialze back to a list of 15 items
 */
util::array<int, 15> DollUnserialize(std::string serialized);

extern Config eoserv_config;
extern Config admin_config;
extern Config drops_config;
extern Config shops_config;

// ewww
class EOClient;
class EOServer;

/**
 * Object which holds and manages all maps and characters on the server, as well as timed events
 * Only one of these should exist per server
 */
class World
{
	private:
		World();

	public:
		Timer timer;

		EOServer *server;

		std::vector<Character *> characters;
		std::vector<Guild *> guilds;
		std::vector<Party *> partys;
		std::vector<Map *> maps;

		int last_character_id;

		util::array<int, 254> exp_table;

		World(util::array<std::string, 5> dbinfo, Config);

		int GenerateCharacterID();
		int GeneratePlayerID();

		void Login(Character *);
		void Logout(Character *);

		void Msg(Character *from, std::string message);
		void AdminMsg(Character *from, std::string message, int minlevel = ADMIN_GUARDIAN);
		void AnnounceMsg(Character *from, std::string message);

		void Reboot();
		void Reboot(int seconds, std::string reason);

		void Kick(Character *from, Character *victim, bool announce = true);
		void Ban(Character *from, Character *victim, double duration, bool announce = true);

		Character *GetCharacter(std::string name);
		Character *GetCharacterPID(unsigned int id);
		Character *GetCharacterCID(unsigned int id);
};

#include "eoclient.hpp"

/**
 * Object representing an item on the floor of a map
 */
struct Map_Item
{
	short uid;
	short id;
	int amount;
	unsigned char x;
	unsigned char y;
	unsigned int owner; // Player ID
	double unprotecttime;
};

/**
 * Object representing a warp tile on a map, as well as storing door state
 */
struct Map_Warp
{
	short map;
	unsigned char x;
	unsigned char y;
	unsigned char levelreq;

	enum WarpSpec
	{
		NoDoor,
		Door,
		LockedSilver,
		LockedCrystal,
		LockedWraith
	};

	WarpSpec spec;
	bool open;

	Map_Warp() : spec(Map_Warp::NoDoor), open(false) {}
};

/**
 * Object representing one tile on a map
 */
struct Map_Tile
{
	enum TileSpec
	{
		None = -1,
		Wall,
		ChairDown,
		ChairLeft,
		ChairRight,
		ChairUp,
		ChairDownRight,
		ChairUpLeft,
		ChairAll,
		Door,
		Chest,
		Unknown1,
		Unknown2,
		Unknown3,
		Unknown4,
		Unknown5,
		Unknown6,
		BankVault,
		NPCBoundary,
		MapEdge,
		FakeWall,
		Board1,
		Board2,
		Board3,
		Board4,
		Board5,
		Board6,
		Board7,
		Board8,
		Jukebox,
		Jump,
		Water,
		Unknown7,
		Arena,
		AmbientSource,
		Spikes1,
		Spikes2,
		Spikes3
	};

	TileSpec tilespec;

	Map_Warp *warp;

	Map_Tile() : tilespec(Map_Tile::None), warp(0) {}

	bool Walkable(bool npc = false)
	{
		if (this->warp && npc)
		{
			return false;
		}

		switch (this->tilespec)
		{
			case Wall:
			case ChairDown:
			case ChairLeft:
			case ChairRight:
			case ChairUp:
			case ChairDownRight:
			case ChairUpLeft:
			case ChairAll:
			case Chest:
			case BankVault:
			case MapEdge:
			case Board1:
			case Board2:
			case Board3:
			case Board4:
			case Board5:
			case Board6:
			case Board7:
			case Jukebox:
				return false;
			case NPCBoundary:
				return !npc;
			default:
				return true;
		}
	}

	~Map_Tile()
	{
		if (this->warp)
		{
			delete this->warp;
		}
	}
};

/**
 * Contains all information about a map, holds reference to contained Characters and manages NPCs on it
 */
class Map
{
	public:
		short id;
		char rid[4];
		bool pk;
		int filesize;
		unsigned char width;
		unsigned char height;
		std::string filename;
		std::vector<Character *> characters;
		std::vector<NPC *> npcs;
		std::vector<Map_Item> items;
		std::vector<std::vector<Map_Tile> > tiles;
		bool exists;

		Map(int id);

		int GenerateItemID();

		void Enter(Character *, WarpAnimation animation = WARP_ANIMATION_NONE);
		void Leave(Character *, WarpAnimation animation = WARP_ANIMATION_NONE);

		void Msg(Character *from, std::string message);
		bool Walk(Character *from, Direction direction, bool admin = false);
		void Attack(Character *from, Direction direction);
		void Face(Character *from, Direction direction);
		void Sit(Character *from, SitAction sit_type);
		void Stand(Character *from);
		void Emote(Character *from, enum Emote emote, bool relay = true);
		bool OpenDoor(Character *from, unsigned char x, unsigned char y);

		bool Walk(NPC *from, Direction direction);

		Map_Item *AddItem(short id, int amount, unsigned char x, unsigned char y, Character *from = 0);
		void DelItem(short uid, Character *from = 0);

		bool InBounds(unsigned char x, unsigned char y);
		bool Walkable(unsigned char x, unsigned char y, bool npc = false);
		Map_Tile::TileSpec GetSpec(unsigned char x, unsigned char y);
		Map_Warp *GetWarp(unsigned char x, unsigned char y);

		void Effect(int effect, int param);

		Character *GetCharacter(std::string name);
		Character *GetCharacterPID(unsigned int id);
		Character *GetCharacterCID(unsigned int id);

		enum OccupiedTarget
		{
			PlayerOnly,
			NPCOnly,
			PlayerAndNPC
		};
		bool Occupied(unsigned char x, unsigned char y, Map::OccupiedTarget target);

		~Map();
};

/**
 * Object representing a player, but not a character
 */
class Player
{
	public:
		int login_time;
		bool online;
		unsigned int id;
		std::string username;
		std::string password;

		Player(std::string username);

		std::vector<Character *> characters;
		Character *character;

		static bool ValidName(std::string username);
		static Player *Login(std::string username, std::string password);
		static bool Create(std::string username, std::string password, std::string fullname, std::string location, std::string email, std::string computer, std::string hdid, std::string ip);
		static bool Exists(std::string username);
		bool AddCharacter(std::string name, int gender, int hairstyle, int haircolor, int race);
		void ChangePass(std::string password);
		static bool Online(std::string username);

		EOClient *client;

		~Player();
};

/**
 * One type of item in a Characters inventory
 */
struct Character_Item
{
	short id;
	int amount;
};

/**
 * One spell that a Character knows
 */
struct Character_Spell
{
	short id;
	unsigned char level;
};

class Character
{
	public:
		int login_time;
		bool online;
		unsigned int id;
		AdminLevel admin;
		std::string name;
		std::string title;
		std::string home;
		std::string partner;
		unsigned char clas;
		Gender gender;
		Skin race;
		unsigned char hairstyle, haircolor;
		short mapid;
		unsigned char x, y, direction;
		short spawnmap;
		unsigned char spawnx, spawny;
		unsigned char level;
		int exp;
		short hp, tp;
		short str, intl, wis, agi, con, cha;
		short statpoints, skillpoints;
		short weight, maxweight;
		short karma;
		SitAction sitting;
		unsigned char visible;
		int bankmax;
		int goldbank;
		int usage;

		short maxsp;
		short maxhp, maxtp;
		short accuracy, evade, armor;
		short mindam, maxdam;

		bool trading;
		Character *trade_partner;
		bool trade_agree;
		std::list<Character_Item> trade_inventory;

		NPC *shop_npc;

		WarpAnimation warp_anim;

		enum EquipLocation
		{
			Boots,
			Accessory,
			Gloves,
			Belt,
			Armor,
			Necklace,
			Hat,
			Shield,
			Weapon,
			Ring1,
			Ring2,
			Armlet1,
			Armlet2,
			Bracer1,
			Bracer2
		};

		std::list<Character_Item> inventory;
		std::list<Character_Item> bank;
		util::array<int, 15> paperdoll;
		std::list<Character_Spell> spells;
		std::list<NPC *> unregister_npc;

		Character(std::string name);

		static bool ValidName(std::string name);
		static bool Exists(std::string name);
		static Character *Create(Player *, std::string name, int gender, int hairstyle, int haircolor, int race);
		static void Delete(std::string name);

		void Msg(Character *from, std::string message);
		bool Walk(Direction direction);
		bool AdminWalk(Direction direction);
		void Attack(Direction direction);
		void Sit(SitAction sit_type);
		void Stand();
		void Emote(enum Emote emote, bool relay = true);
		int HasItem(short item);
		bool AddItem(short item, int amount);
		bool DelItem(short item, int amount);
		bool AddTradeItem(short item, int amount);
		bool DelTradeItem(short item);
		bool Unequip(short item, unsigned char subloc);
		bool Equip(short item, unsigned char subloc);
		bool InRange(unsigned char x, unsigned char y);
		bool InRange(Character *);
		bool InRange(NPC *);
		bool InRange(Map_Item);
		void Warp(short map, unsigned char x, unsigned char y, WarpAnimation animation = WARP_ANIMATION_NONE);
		void Refresh();
		std::string PaddedGuildTag();
		int Usage();
		void CalculateStats();

		void Save();

		~Character();

		Player *player;
		Guild *guild;
		std::string guild_tag;
		unsigned char guild_rank;
		Party *party;
		Map *map;
};

/**
 * Used by the NPC class to store information about an attacker
 */
struct NPC_Opponent
{
	Character *attacker;
	unsigned short damage;
	double last_hit;
};

/**
 * Used by the NPC class to store information about an item drop
 */
struct NPC_Drop
{
	unsigned short id;
	int min;
	int max;
	double chance;
};

/**
 * Used by the NPC class to store trade shop data
 */
struct NPC_Shop_Trade_Item
{
	unsigned short id;
	int buy;
	int sell;
};

/**
 * Used by the NPC_Shop_Craft_Item class to store item ingredients
 */
struct NPC_Shop_Craft_Ingredient
{
	unsigned short id;
	unsigned char amount;
};

/**
 * Used by the NPC class to store craft shop data
 */
struct NPC_Shop_Craft_Item
{
	unsigned short id;
	std::vector<NPC_Shop_Craft_Ingredient> ingredients;
};

extern double npc_speed_table[8];

/**
 * An instance of an NPC created and managed by a Map
 */
class NPC
{
	public:
		short id;
		ENF_Data *data;
		unsigned char x, y;
		Direction direction;
		unsigned char spawn_type;
		short spawn_time;
		unsigned char spawn_x, spawn_y;
		NPC *parent;
		std::vector<NPC_Drop> drops;
		std::string shop_name;
		std::vector<NPC_Shop_Trade_Item> shop_trade;
		std::vector<NPC_Shop_Craft_Item> shop_craft;

		bool alive;
		double dead_since;
		double last_act;
		double act_speed;
		int walk_idle_for;
		bool attack;
		int hp;
		int totaldamage;
		std::list<NPC_Opponent> damagelist;

		Map *map;
		unsigned char index;

		NPC(Map *map, short id, unsigned char x, unsigned char y, unsigned char spawn_type, short spawn_time, unsigned char index);

		bool SpawnReady();

		void Spawn();
		void Act();

		bool Walk(Direction);
		void Damage(Character *from, int amount);

		void Attack(Character *target);
};

/**
 * Stores guild information and references to online members
 * Created by the World object when a member of the guild logs in, and destroyed when the last member logs out
 */
class Guild
{
	public:
		std::string tag;
		std::string name;
		std::vector<Character *> members;
		util::array<std::string, 9> ranks;
		std::time_t created;

		void Msg(Character *from, std::string message);
};

/**
 * A temporary group of Characters
 */
class Party
{
	public:
		Party(Character *host, Character *other);

		Character *host;
		std::vector<Character *> members;

		void Msg(Character *from, std::string message);
		void Join(Character *);
		void Part(Character *);
};

#endif // EOSERV_HPP_INCLUDED
